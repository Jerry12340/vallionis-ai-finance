{% extends "base.html" %}

{% block title %}AI Coach - Vallionis AI Finance{% endblock %}

{% block content %}
<div class="chat-container">
    <h2>💬 AI Finance Coach</h2>
    <div id="chat-box" class="chat-box"></div>

    <form id="chat-form">
        <textarea id="user-input" placeholder="Ask me anything about investing..." rows="1" autocomplete="off" required></textarea>
        <button id="send-btn" type="submit">Send</button>
    </form>
</div>
{% endblock %}

{% block scripts %}
<script>
    const chatBox = document.getElementById("chat-box");
    const chatForm = document.getElementById("chat-form");
    const userInput = document.getElementById("user-input");
    const sendBtn = document.getElementById("send-btn");

    // Basic HTML escape to prevent XSS
    function escapeHtml(str) {
        return String(str)
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
    }

    // Very small, safe-ish Markdown renderer for bold/italic/inline-code + line breaks
    function renderMarkdownSafe(str) {
        let s = escapeHtml(str);
        // inline code first to avoid interfering with * patterns
        s = s.replace(/`([^`]+)`/g, '<code>$1</code>');
        // bold **text**
        s = s.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
        // italic *text*
        s = s.replace(/(?<!\*)\*(?!\*)(.+?)(?<!\*)\*(?!\*)/g, '<em>$1</em>');
        // line breaks
        s = s.replace(/\n/g, '<br>');
        return s;
    }

    // Helper to append messages
    function addMessage(sender, text) {
        const msg = document.createElement("div");
        msg.classList.add("message", sender);
        const label = `<strong>${sender === "user" ? "You" : "AI"}:</strong> `;
        const body = sender === "ai" ? renderMarkdownSafe(text) : escapeHtml(text);
        msg.innerHTML = label + body;
        chatBox.appendChild(msg);
        chatBox.scrollTop = chatBox.scrollHeight; // auto scroll
    }

    chatForm.addEventListener("submit", async (e) => {
        e.preventDefault();
        const message = userInput.value.trim();
        if (!message) return;

        // Show user message
        addMessage("user", message);
        userInput.value = "";

        // Show loading message
        const loading = document.createElement("div");
        loading.classList.add("message", "ai");
        loading.textContent = "AI is thinking...";
        chatBox.appendChild(loading);
        chatBox.scrollTop = chatBox.scrollHeight;

        // Disable input while processing
        userInput.disabled = true;
        sendBtn.disabled = true;
        const originalBtnText = sendBtn.textContent;
        sendBtn.textContent = "Processing...";

        // AbortController for timeout
        const controller = new AbortController();
        const timeoutMs = 600000; // 600s safety timeout
        const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

        try {
            const response = await fetch("/api/ai/chat", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ message }),
                signal: controller.signal
            });

            // Handle non-OK responses explicitly
            if (!response.ok) {
                let errText = "Service error.";
                try {
                    const errJson = await response.json();
                    // Friendly handling for token limit
                    if (response.status === 413 && errJson?.code === 'TOKEN_LIMIT') {
                        if (loading && loading.parentNode) {
                            chatBox.removeChild(loading);
                        }
                        const msg = errJson.message || 'You have used too many tokens for your current plan.';
                        const tier = errJson.tier ? ` (plan: ${errJson.tier})` : '';
                        addMessage("ai", `⚠️ ${msg}${tier}`);
                        return;
                    }
                    errText = errJson?.error || JSON.stringify(errJson);
                } catch (_) {}
                if (loading && loading.parentNode) {
                    chatBox.removeChild(loading);
                }
                addMessage("ai", `⚠️ ${errText}`);
                return;
            }

            const data = await response.json();
            if (loading && loading.parentNode) {
                chatBox.removeChild(loading); // remove loading text
            }

            const reply = data.reply || data.response || data.message;
            if (reply) {
                addMessage("ai", reply);
            } else {
                addMessage("ai", "⚠️ Sorry, something went wrong.");
            }
        } catch (error) {
            console.error(error);
            if (loading && loading.parentNode) {
                chatBox.removeChild(loading);
            }
            if (error.name === 'AbortError') {
                addMessage("ai", "⚠️ The request timed out. Please try again.");
            } else {
                addMessage("ai", "⚠️ Error contacting AI.");
            }
        } finally {
            clearTimeout(timeoutId);
            userInput.disabled = false;
            sendBtn.disabled = false;
            sendBtn.textContent = originalBtnText;
            userInput.focus();
        }
    });

    // Auto-grow textarea up to 8 lines, then scroll
    function autoResizeTextarea(el, maxLines = 8) {
        const style = window.getComputedStyle(el);
        const lineHeight = parseFloat(style.lineHeight) || 20; // fallback
        const borderTop = parseFloat(style.borderTopWidth) || 0;
        const borderBottom = parseFloat(style.borderBottomWidth) || 0;
        const paddingTop = parseFloat(style.paddingTop) || 0;
        const paddingBottom = parseFloat(style.paddingBottom) || 0;
        const maxHeight = maxLines * lineHeight + paddingTop + paddingBottom + borderTop + borderBottom;

        el.style.height = 'auto';
        const newHeight = Math.min(el.scrollHeight, maxHeight);
        el.style.height = newHeight + 'px';
        el.style.overflowY = el.scrollHeight > maxHeight ? 'auto' : 'hidden';
    }

    // Initialize and bind
    autoResizeTextarea(userInput, 8);
    userInput.addEventListener('input', () => autoResizeTextarea(userInput, 8));
</script>

<style>
    .chat-container {
        max-width: 800px;
        margin: 2rem auto;
        padding: 1.5rem;
        background: var(--color-card-bg);
        border: 1px solid var(--color-border);
        border-radius: 12px;
        box-shadow: 0 4px 10px var(--color-card-shadow);
    }

    .chat-box {
        height: 400px;
        overflow-y: auto;
        border: 1px solid var(--color-border);
        border-radius: 8px;
        padding: 1rem;
        background: var(--color-bg-secondary);
        margin-bottom: 1rem;
    }

    .message {
        margin-bottom: 0.75rem;
        line-height: 1.4;
    }

    .message.user {
        text-align: right;
        color: var(--color-primary);
    }

    .message.ai {
        text-align: left;
        color: var(--color-text);
    }

    #chat-form {
        display: flex;
        gap: 0.5rem;
    }

    #user-input {
        flex: 1;
        padding: 0.75rem;
        border-radius: 8px;
        border: 1px solid var(--color-border);
    }

    #chat-form button {
        padding: 0.75rem 1.25rem;
        background: var(--color-primary);
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-weight: 600;
    }

    #chat-form button:hover {
        background: var(--color-primary-hover);
    }
</style>
{% endblock %}
